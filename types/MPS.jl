# the struct is treated as a const which cannot be replaced during runtime --> if attributes change, restart REPL

# struct and constructors for finite MPS
mutable struct MPS{A<:MPSTensor,B<:MPSBondTensor}
    ALs::Vector{A}
    ACs::Vector{A}
    CMs::Vector{B}
    ARs::Vector{A}
end

# constructor for initialization with tensor train
function MPS(site_tensors::Vector{A}) where {A<:MPSTensor}

    # bring MPS into right-canonical form
    for i in length(site_tensors) : -1 : 2
        (L, Q) = rightorth(site_tensors[i],(1,),(2,3),alg=LQpos())
        site_tensors[i] = permute(Q, (1,2), (3,))
        site_tensors[i-1] = site_tensors[i-1] * L
    end
    (L, QR) = rightorth(site_tensors[1],(1,),(2,3),alg=LQpos())
    (QL, R) = leftorth(site_tensors[1],(1,2),(3,),alg=QRpos())
    B = typeof(R);

    # initialize empty vectors
    ALs = Vector{A}(undef,length(site_tensors))
    ACs = Vector{A}(undef,length(site_tensors))
    CMs = Vector{B}(undef,length(site_tensors))
    ARs = Vector{A}(undef,length(site_tensors))

    norm = @tensor site_tensors[1][1 2 3] * conj(site_tensors[1][1 2 3])
    site_tensors[1] = site_tensors[1]/sqrt(norm)

    @tensor norm[:] := site_tensors[1][1 2 -1] * conj(site_tensors[1][1 2 -2])
    for i = 2 : length(ARs) - 1
        @tensor norm[:] := norm[1 2] * site_tensors[i][1 3 -1] * conj(site_tensors[i][2 3 -2])
    end
    norm = @tensor norm[1 2] * site_tensors[end][1 3 4] * conj(site_tensors[end][2 3 4])
    if abs(norm - 1e0) > 1e-12
        println(norm)
        throw(ErrorException("Norm of MPS not sufficiently close to 1.0. Norm is: " * string(norm)))
    end

    # store tensors
    ACs[1] = site_tensors[1]
    CMs[1] = R
    ARs[1] = permute(QR, (1,2), (3,))
    ALs[1] = QL
    ARs[2:end] .= site_tensors[2:end]

    # call the default constructor and assign its attributes
    MPS{A,B}(ALs, ACs, CMs, ARs)

end

function MPS(model::Model ; init::Function = randn)
    
    # extract list of physical spaces from the MPO
    physSpaces = [space(mpo,4)' for mpo in model.H.mpo]
    # the virtual spaces are stored in the Q attribute of model
    virtSpaces = model.Q
    
    # generate the MPS tensor train with elements generated by init()
    mpsSiteTensors = [TensorMap(init, model.P["eltype"], virtSpaces[i] ⊗ physSpaces[i], virtSpaces[i+1]) for i = 1 : length(physSpaces)]

    # mpsLinkTensors = TensorMap(init, model.P["eltype"], virtSpaces[1], virtSpaces[1])
    MPS(mpsSiteTensors)

end

# struct and constructors for infinite MPS
mutable struct InfiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor}
    ALs::PeriodicArray{A,1}
    ARs::PeriodicArray{A,1}
    CMs::PeriodicArray{B,1}
    ACs::PeriodicArray{A,1}
end

function InfiniteMPS(model::Model ; init::Function = randn)
    
    # extract list of physical spaces from the MPO
    physSpaces = [space(mpo,4)' for mpo in model.H.mpo]
    # the virtual spaces are stored in the Q attribute of model
    virtSpaces = model.Q
    
    # generate the MPS tensor train with elements generated by init()
    mpsSiteTensors = [TensorMap(init, model.P["eltype"], virtSpaces[i] ⊗ physSpaces[i], virtSpaces[i+1]) for i = 1 : length(physSpaces)]

    # mpsLinkTensors = TensorMap(init, model.P["eltype"], virtSpaces[1], virtSpaces[1])
    InfiniteMPS(mpsSiteTensors)

end

# constructor for initialization with tensor train
function InfiniteMPS(site_tensors::Vector{A}) where {A<:MPSTensor}

    # bring MPS into right-canonical form
    for i in length(site_tensors) : -1 : 2
        (L, Q) = rightorth(site_tensors[i],(1,),(2,3),alg=LQpos())
        site_tensors[i] = permute(Q, (1,2), (3,))
        site_tensors[i-1] = site_tensors[i-1] * L
    end
    (L, QR) = rightorth(site_tensors[1],(1,),(2,3),alg=LQpos())
    (QL, R) = leftorth(site_tensors[1],(1,2),(3,),alg=QRpos())
    B = typeof(R);

    # initialize empty vectors
    ALs = PeriodicArray{A}(undef,length(site_tensors))
    ACs = PeriodicArray{A}(undef,length(site_tensors))
    CMs = PeriodicArray{B}(undef,length(site_tensors))
    ARs = PeriodicArray{A}(undef,length(site_tensors))

    norm = @tensor site_tensors[1][1 2 3] * conj(site_tensors[1][1 2 3])
    site_tensors[1] = site_tensors[1]/sqrt(norm)

    @tensor norm[:] := site_tensors[1][1 2 -1] * conj(site_tensors[1][1 2 -2])
    for i = 2 : length(ARs) - 1
        @tensor norm[:] := norm[1 2] * site_tensors[i][1 3 -1] * conj(site_tensors[i][2 3 -2])
    end
    norm = @tensor norm[1 2] * site_tensors[end][1 3 4] * conj(site_tensors[end][2 3 4])
    if abs(norm - 1e0) > 1e-12
        println(norm)
        throw(ErrorException("Norm of MPS not sufficiently close to 1.0. Norm is: " * string(norm)))
    end

    # store tensors
    ACs[1] = site_tensors[1]
    CMs[1] = R
    CMs[end] = L
    ARs[1] = permute(QR, (1,2), (3,))
    ALs[1] = QL
    ARs[2:end] .= site_tensors[2:end]

    # call the default constructor and assign its attributes
    InfiniteMPS{A,B}(ALs, ACs, CMs, ARs)

end